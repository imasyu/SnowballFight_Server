#include "UdpServer.h"
#include <WS2tcpip.h>
#include "Player.h"
#include "NetworkManager.h"

namespace {
	// ポート番号
	const unsigned short SERVERPORT = 8888;
	// 送受信するメッセージの最大値
	const unsigned int MESSAGELENGTH = 1024;

}

int UdpServer::CreateSocket(std::string port)
{
	port_ = port;
	
	// リスンソケットの作成
	sock_ = socket(AF_INET, SOCK_DGRAM, 0);
	if (sock_ == INVALID_SOCKET)
	{
		OutputDebugString("リスンソケット作成失敗\n");
		return 0;
	}

	// bind
	struct sockaddr_in bindAddr;	// bind用のソケットアドレス情報
	memset(&bindAddr, 0, sizeof(bindAddr));
	bindAddr.sin_family = AF_INET;
	bindAddr.sin_port = htons(SERVERPORT);
	bindAddr.sin_addr.s_addr = htonl(INADDR_ANY);

	// ソケットアドレス情報設定	※固定のポート番号設定
	if (bind(sock_, (struct sockaddr*)&bindAddr, sizeof(bindAddr)) != 0)
	{
		OutputDebugString("ソケットアドレスの設定エラー\n");
		closesocket(sock_);  // ソケットを閉じる
		return 0;
	}

	// ソケットsockをノンブロッキングソケットにする
	unsigned long cmdarg = 0x01;
	int ret = ioctlsocket(sock_, FIONBIO, &cmdarg);
	if (ret == SOCKET_ERROR)
	{
		OutputDebugString("ノンブロッキングソケット化失敗\n");
		closesocket(sock_);  // ソケットを閉じる
		return 0;
	}

	return 1;
}

int UdpServer::Update()
{
	//受信
	DATA data;
	if (Recv(sock_, &data)) {
		data.posX = (data.posX / MAGNFICATION);
		data.posZ = (data.posZ / MAGNFICATION);
		data.rotateY = (data.rotateY / MAGNFICATION);
		OutputDebugString(("X = " + std::to_string(data.posX) + " : Y = " + std::to_string(data.posZ) + "\n").c_str());
	}
	else {
		OutputDebugString("受信エラー\n");
		return 0;
	}

	//送信
	XMFLOAT3 pos = NetworkManager::GetSelfPlayer()->GetPosition();
	data.posX = (pos.x * MAGNFICATION);
	data.posZ = (pos.z * MAGNFICATION);
	data.rotateY = (NetworkManager::GetSelfPlayer()->GetRotate().y * MAGNFICATION);

	if (!Send(sock_, data)) {
		OutputDebugString("送信エラー\n");
		return 0;
	}

	return 1;
}
